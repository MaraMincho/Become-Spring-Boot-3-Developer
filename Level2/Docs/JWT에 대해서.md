# JWT
발급받은 JWT를 이용해 인증을 하려면 HTTP 요청 헤더 중에 Authorization 키값에 Bearer + JWT 토큰값을 넣어 보내야 합니다.

그렇다면 JWT는 어떠한 구조로 이루어져 있을까요? JWT는 .을 기준으로 헤더header, 내용payload, 서명signature으로 이루어져 있습니다. 각각 무슨 역할을 하는지 간단하게 알아보겠습니다.


![alt text](/Images/image2.png)
## 헤더

헤더에는 토큰의 타입과 해싱 알고리즘을 지정하는 정보를 담습니다. 다음의 경우 JWT 토큰,HS256 해싱 알고리즘을 사용한다는 내용입니다.
```js
{
    "typ": "JWT", //토큰의 타입을 지정합니다. JWT라는 문자열이 들어가게 됩니다.
    "alg": "HS256" // 해싱 알고리즘을 지정합니다. 
}
```

## 내용

내용에는 토큰과 관련된 정보를 담습니다. 내용의 한 덩어리를 클레임(claim)이라고 부르며,클레임은 키값의 한 쌍으로 이루어져 있습니다. 클레임은 `등록된 클레임`, `공개 클레임`, `비공개 클레임`으로 나눌 수 있습니다.

### 등록된 클레임

등록된 클레임registered claim은 토큰에 대한 정보를 담는 데 사용합니다.

|이름 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|설명|
|:-|:-|
|iss| 토큰 발급자(issuer)|
|sub| 토큰 제목(subject)|
|aud| 토큰 대상자(audience)|
|exp| 토큰의 만료 시간(expiraton). 시간은 NumericDate 형식으로 하며(예: 1480849147370), 항상 현재 시간 이후로설정합니다.|
|nbf| 토큰의 활성 날짜와 비슷한 개념으로 nbf는 Not Before를 의미합니다.NumericDate 형식으로 날짜를 지정하며,이 날짜가 지나기 전까지는 토큰이 처리되지 않습니다.|
|iat| 토큰이 발급된 시간으로 iat은 issued at을 의미합니다.|
|jti| JWT의 고유 식별자로서 주로 일회용 토큰에 사용합니다.|




### 공개 클레임
공개 클레임public claim은 공개되어도 상관없는 클레임을 의미합니다. 충돌을 방지할 수 있는 이름을 가져야 하며, 보통 클레임 이름을 URI로 짓습니다.


### 비공개 클레임
비공개 클레임private claim은 공개되면 안 되는 클레임을 의미합니다. 클라이언트와 서버 간의 통신에 사용됩니다.

```js
{
    "iss": "ajufresh@gmail.com", // 등록된 클레임
    "iat": 1622370878, // 등록된 클레임
    "exp": 1622372678, // 등록된 클레임
    "https://shinsunyoung.com/jwt_claims/is_admin": true, // 공개 클레임
    "email": "ajufresh@gmail.com", // 비공개 클레임
    "hello": "안녕하세요!" // 비공개 클레임
}
```

## 서명

서명은 해당 토큰이 조작되었거나 변경되지 않았음을 확인하는 용도로 사용하며, 헤더의 인코딩값과 내용의 인코딩값을 합친 후에 주어진 비밀키를 사용해 해시값을 생성합니다.


# 리프레시 토큰의 효용
토큰을 탈취당해도, 일정 시간이 지나서 탈취당한 토큰이 expired되도 어차피 리프레시토큰으로 재발급 받으면 문제 없어짐.


# 토큰 발급 과정 및 리프레시 토큰 응답 정리

![alt text](/Images/image4.png)
1. 클라이언트가 서버에게 인증을 요청합니다. 
2. 서버는 클라이언트에서 전달한 정보를 바탕으로 인증 정보가 유효한지 확인한 뒤, 액세스 토큰과 리프레시 토큰을 만들어 클라이언트에게 전달합니다. 클라이언트는 전달받은 토큰을 저장합니다.
3. 서버에서 생성한 리프레시 토큰은 DB에도저장해둡니다.
4. 인증을 필요로 하는 API를 호출할 때 클라이언트에 저장된 액세스 토큰과 함께API를 요청합니다.
5. 서버는 전달받은 액세스 토큰이 유효한지 검사한 뒤에 유효하다면 클라이언트에서 요청한 내용을 처리합니다. 
6. 시간이 지나고 액세스 토큰이 만료된 뒤에 클라이언트에서원하는 정보를 얻기 위해 서버에게 API 요청을 보냅니다.
7. 서버는 액세스 토큰이 유효한지 검사합니다. 만료된 토큰이면 유효하지 않기 때문에 토큰이 만료되었다는 에러를 전달합니다. 
8. 클라이언트는 이 응답을 받고 저장해둔 리프레시 토큰과 함께 새로운 액세스 토큰을 발급하는 요청을전송합니다.
9. 서버는 전달받은 리프레시 토큰이 유효한지, DB에서 리프레시 토큰을 조회한 후
저장해둔 리프레시 토큰과 같은지 확인합니다.
10. 만약 유효한 리프레시 토큰이라면 새로운 액세스 토큰을 생성한 뒤 응답합니다. 그 이후에 클라이언트는 4 번과 같이 다시 API를 요청합니다.



### 서버가 JWT를 검증하고 만료를 확인하는 과정
1. 토큰 디코딩 및 분리
    - 클라이언트로부터 받은 JWT는 .으로 구분된 세 파트로 이루어져 있습니다.
        - `header.payload.signature`
    - 서버는 헤더와 페이로드 부분을 Base64 디코딩하여 읽습니다.
        - 디코딩된 페이로드에서 만료 시간(exp)을 확인할 수 있습니다.


2. 서명 검증
    - 서버는 토큰의 헤더와 페이로드를 재조합하여 서명을 생성합니다. 이때 서버는 클라이언트와 공유되지 않은 **비밀 키(secret)**를 사용합니다.
    - 생성된 서명과 클라이언트가 제공한 서명을 비교하여 변조 여부를 확인합니다.

3. 만료 시간 확인
    - 페이로드에서 exp 클레임 값을 가져옵니다. 이 값은 UNIX 타임스탬프(초 단위)로 표현됩니다.
    - 현재 시간과 비교하여 토큰이 만료되었는지 확인합니다.


# 추가 질문 사항
### 근데 RefreshToken이랑 AccessToken이랑 둘 다 탈취 당하면 어떻게 해결해야 함?

